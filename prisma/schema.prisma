// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Status {
  DRAFT
  PENDING
  APPROVED
  REJECTED
}

enum Role {
  USER
  LANDLORD
  ADMIN
}

/**
 * NEW enums
 */
enum NeighborhoodVibe {
  QUIET
  MODERATE
  BUSY
}

enum AreaType {
  URBAN
  SUBURBAN
  RURAL
}

enum ParkingType {
  STREET
  ON_SITE
  NONE
}

enum PetPolicy {
  NONE
  CATS
  DOGS
  CATS_AND_DOGS
  RESTRICTED
}

enum LaundryType {
  IN_UNIT
  SHARED
  NONE
}

enum IdStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?
  role          Role      @default(USER)
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  listings           Listing[]
  verificationTokens VerificationToken[]
  landlordProfile    LandlordProfile?

  // NEW back-relations for messaging
  conversationMemberships ConversationParticipant[] @relation("ConversationMembers")
  sentMessages            Message[]                 @relation("UserMessages")
}

model VerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/**
 * NEW: landlord onboarding & verification
 */
model LandlordProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  fullName        String
  phone           String
  phoneVerifiedAt DateTime?
  dob             DateTime?
  addressLine1    String
  addressLine2    String?
  city            String
  region          String?
  country         String
  postal          String

  idStatus      IdStatus @default(UNVERIFIED)
  kycProvider   String?
  kycRef        String?
  addressDocUrl String?

  // dev-mode OTP
  phoneOtpHash    String?
  phoneOtpExpires DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Listing {
  id          String   @id @default(cuid())
  title       String
  city        String
  price       Int // monthly price in cents
  beds        Int
  baths       Int
  status      Status   @default(DRAFT) // safer default for the wizard
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  landlordId String?
  landlord   User?   @relation(fields: [landlordId], references: [id])

  // Media
  images   Json? // string[]
  videos   Json?
  videoUrl String?

  // Property metadata & neighborhood/amenities
  propertyType     String?
  neighborhoodVibe NeighborhoodVibe?
  areaType         AreaType?

  distanceBusMeters      Int?
  distanceGroceryMeters  Int?
  distanceSchoolMeters   Int?
  distanceParkMeters     Int?
  distancePharmacyMeters Int?
  distanceGymMeters      Int?

  parkingType   ParkingType?
  petPolicy     PetPolicy?
  accessibility Json? // string[]
  laundry       LaundryType?

  heating   String?
  cooling   String?
  furnished Boolean?

  utilitiesIncluded Json? // string[]
  minLeaseMonths    Int?
  maxOccupants      Int?
  smokingAllowed    Boolean?
  houseRules        String?

  // optional deposit used by pricing step
  depositCents Int?

  // NEW back-relation to conversations
  conversations Conversation[] @relation("ListingConversations")
}

model Conversation {
  id            String    @id @default(cuid())
  listingId     String?
  listing       Listing?  @relation("ListingConversations", fields: [listingId], references: [id], onDelete: SetNull)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?

  participants ConversationParticipant[]
  messages     Message[]

  @@index([lastMessageAt])
}

model ConversationParticipant {
  conversationId String
  userId         String
  joinedAt       DateTime  @default(now())
  lastReadAt     DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation("ConversationMembers", fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  body           String
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("UserMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}
