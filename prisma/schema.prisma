generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

/**
 * ---------------------------- Enums ----------------------------
 */

enum Status {
  DRAFT
  PENDING
  APPROVED
  REJECTED
}

enum Role {
  USER
  LANDLORD
  ADMIN
}

/**
 * NEW enums
 */
enum NeighborhoodVibe {
  QUIET
  MODERATE
  BUSY
}

enum AreaType {
  URBAN
  SUBURBAN
  RURAL
}

enum ParkingType {
  STREET
  ON_SITE
  NONE
}

enum PetPolicy {
  NONE
  CATS
  DOGS
  CATS_AND_DOGS
  RESTRICTED
}

enum LaundryType {
  IN_UNIT
  SHARED
  NONE
}

enum IdStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

enum ViewingStatus {
  PENDING
  APPROVED
  DECLINED
  CANCELLED
}

/**
 * ---------------------------- Models ---------------------------
 */
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?
  role          Role      @default(USER)
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  listings           Listing[]
  verificationTokens VerificationToken[] // keep as an array if you issue multiple tokens
  landlordProfile    LandlordProfile? // 1:1 side

  conversationMemberships ConversationParticipant[] @relation("ConversationMembers")
  sentMessages            Message[]                 @relation("UserMessages")
  favorites               Favorite[]

  renterViewingRequests   ViewingRequest[] @relation("RenterViewingRequests")
  landlordViewingRequests ViewingRequest[] @relation("LandlordViewingRequests")
}

model VerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/**
 * NEW: landlord onboarding & verification
 */
model LandlordProfile {
  id String @id @default(cuid())

  // MUST be unique for a 1:1 relation
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  fullName        String
  phone           String
  phoneVerifiedAt DateTime?
  dob             DateTime?
  addressLine1    String
  addressLine2    String?
  city            String
  region          String?
  country         String
  postal          String

  idStatus      IdStatus @default(UNVERIFIED)
  kycProvider   String?
  kycRef        String?
  addressDocUrl String?

  // dev-mode OTP
  phoneOtpHash    String?
  phoneOtpExpires DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Listing {
  id          String   @id @default(cuid())
  title       String
  city        String
  price       Int // monthly price in cents
  beds        Int
  baths       Int
  status      Status   @default(DRAFT)
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  landlordId String?
  landlord   User?   @relation(fields: [landlordId], references: [id])

  // Media
  images   Json?
  videos   Json?
  videoUrl String?

  // Property metadata & neighborhood/amenities
  propertyType     String?
  neighborhoodVibe NeighborhoodVibe?
  areaType         AreaType?

  distanceBusMeters      Int?
  distanceGroceryMeters  Int?
  distanceSchoolMeters   Int?
  distanceParkMeters     Int?
  distancePharmacyMeters Int?
  distanceGymMeters      Int?

  parkingType   ParkingType?
  petPolicy     PetPolicy?
  accessibility Json?
  laundry       LaundryType?

  heating   String?
  cooling   String?
  furnished Boolean?

  utilitiesIncluded Json?
  minLeaseMonths    Int?
  maxOccupants      Int?
  smokingAllowed    Boolean?
  houseRules        String?

  depositCents Int?

  // Messaging back-relation
  conversations Conversation[] @relation("ListingConversations")

  // Favorites back-relation
  favoritedBy Favorite[]

  // NEW: ViewingRequest back-relation
  viewingRequests ViewingRequest[]
}

model Conversation {
  id            String    @id @default(cuid())
  listingId     String?
  listing       Listing?  @relation("ListingConversations", fields: [listingId], references: [id], onDelete: SetNull)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?

  participants ConversationParticipant[]
  messages     Message[]

  @@index([lastMessageAt])
}

model ConversationParticipant {
  conversationId String
  userId         String
  joinedAt       DateTime  @default(now())
  lastReadAt     DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation("ConversationMembers", fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  body           String
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("UserMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

model Favorite {
  userId    String
  listingId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@id([userId, listingId])
}

/**
 * ----------------------- Viewing Requests ----------------------
 */

model ViewingRequest {
  id         String @id @default(cuid())
  listingId  String
  renterId   String
  landlordId String

  note String? // SQLite: no @db.Text

  // up to 3 proposed slots in UTC
  slot1Start DateTime?
  slot1End   DateTime?
  slot2Start DateTime?
  slot2End   DateTime?
  slot3Start DateTime?
  slot3End   DateTime?

  chosenStart DateTime?
  chosenEnd   DateTime?

  status    ViewingStatus @default(PENDING)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  listing  Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  renter   User    @relation("RenterViewingRequests", fields: [renterId], references: [id], onDelete: Cascade)
  landlord User    @relation("LandlordViewingRequests", fields: [landlordId], references: [id], onDelete: Cascade)

  @@index([landlordId, status, createdAt])
  @@index([renterId, createdAt])
}
